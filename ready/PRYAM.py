# Определяем коэффициенты Студента. Это некие постоянные которые юзаются для расчётов в дальнейшем.
# (насколько слажал экспериментатор)
# при расчете через СКО

Koef_t = {
    2:12.7,
    3:4.3,
    4:3.2,
    5:2.8,
    6:2.6,
    7:2.5,
    8:2.4,
    9:2.3,
    10:2.3,
    100:2.0
}


# Определяем коэффициенты Бета при расчете доверительной погрешности (насколько слажал экспериментатор)
# при расчете через размах

Koef_Beta = {
    3:1.30,
    4:0.72,
    5:0.51,
    6:0.40,
    7:0.33,
    8:0.29,
    9:0.25,
    10:0.23,
    11:0.21,
    12:0.19
}

# Определяем коэффициенты Ю при расчете на наличие грубых промахов (если экспериментатор нафлексил вообще левые размеры)
# при расчете через размах

Koef_u = {
    3:0.94,
    4:0.76,
    5:0.64,
    7:0.51,
    10:0.41,
    15:0.34,
    20:0.30,
    30:0.26,
    100:0.20
}


# Определяем коэффициенты Ви при расчете на наличие грубых промахов
# (если экспериментатор нафлексил вообще левые размеры)
# при расчете через СКО

Koef_V = {
    3:1.15,
    4:1.46,
    5:1.67,
    6:1.82,
    7:1.94,
    8:2.03,
    9:2.11,
    10:2.18,
    11:2.23,
    12:2.29
}


# Функция расчета (можно в том числе импортировать куда угодно если я сделаю калк для косвенных).

def pryam_pogr(vbka, prib_pogr, letter='X', izmer='Гц'):
    """
    :param vbka: Передайте сюда список int или float значений выборки
    :param prib_pogr: Передайте сюда приборную погрешность (int или float)
    :param letter:  Передайте сюда str любой буквы которую вы вычисляете
    :param izmer: Передайте сюда str любой величины, которую будете вычислять
    :return:
    """
    # Цикл я юзаю для того чтобы отсмотреть все грубые промахи и если что исключить и пересчитать все это

    while True:

        # запись выборки
        print("-"*40+
              "\nЗапишем выборку\n"
              f"\n{' | '.join([f'{i} {izmer}' for i in vbka])}"
              "\n")

        # Ранжа выборки
        ranged_vbka = sorted(vbka)
        print("-"*40+
              "\nРанжируем выборку (сортируем по возрастанию)\n"
              f"\n{' | '.join([f'{i} {izmer}' for i in ranged_vbka])}"
              "\n")

        # определение объема
        N = len(ranged_vbka)
        print("-"*40+
              "\nОбъем выборки:\n"
              f"\nN={N}"
              "\n")

        # размах выборки
        R = abs(ranged_vbka[0] - ranged_vbka[-1])
        print("-"*40+
              "\nРазмах выборки:"
              f"\nR={R} {izmer}"
              "\n")

        # среднее по выборке
        X_ = sum(ranged_vbka) / N
        print("-"*40+
              f"\nСреднее по выборке:"
              f"\n{letter}‾ = {X_} {izmer}"
              "\n")


        # СКО
        SKO1 = 0


        dxil = []
        for x in ranged_vbka:
            dxil.append(x-X_)
            SKO1 += (x - X_)**2

        print("-" * 40 +
              f"\n Разница между элементами и средним (∆X i-тое):"
              f"\n{' | '.join([f'{i} {izmer}' for i in dxil])}"
              "\n")

        dxil2 = []

        for x in ranged_vbka:
            dxil2.append((x-X_)**2)

        print("-" * 40 +
              f"\n Разница между элементами и средним (∆X i-тое) в квадрате:"
              f"\n{' | '.join([f'{i} ({izmer})^2' for i in dxil2])}"
              "\n")

        print("-" * 40 +
              f"\n Сумма элементов перед расчетом СКО:"
              f"\n {SKO1} ({izmer})^2"
              "\n")


        Sx = (SKO1/(N-1))**0.5

        print("-" * 40 +
              f"\n СКО:"
              f"\nS({letter}) = {Sx} {izmer}"
              "\n")

        # Проверка на промахи будет тут. для этого был сделан цикл, чтобы все опять с нуля повторялось
        # Проверка будет по размаху, если что то не устроило, пишите, допилю (а лучше сами, это правда вообще не трудно)

        check1 = abs(ranged_vbka[0] - ranged_vbka[1])

        print("-" * 40 +
              f"\n Коэффициент Размаха U:"
              f"\n{Koef_u[N]}"
              "\n")

        print("-" * 40 +
              f"\n Итоговое максимальное значение отклонения (U..R):"
              f"\n{Koef_u[N] * R} {izmer}"
              "\n")


        if check1 < Koef_u[N] * R:
            pass
        else:

            print("!" * 40+
                '\nОбнаружен промах! Удаляю и провожу вычисления заново')
            ranged_vbka.pop(0)

        check2 = abs(ranged_vbka[-1] - ranged_vbka[-2])

        if check2 < Koef_u[N]*R:
            print("-" * 40+
                '\nПромахов не обнаружено')
            break
        else:
            print("!" * 40+
                '\nОбнаружен промах! Удаляю и провожу вычисления заново')
            ranged_vbka.pop(-1)

    # СКО среднего
    Sx_ = Sx / (N**0.5)
    print("-" * 40 +
          f"\n СКО среднего:"
          f"\nS({letter}‾) = {Sx_} {izmer}"
          "\n")

    # Случайная погрешность - тоже по промаху, не колышет :)

    print("-" * 40 +
          f"\n Коэффициент Бета для расчета случайной погрешности:"
          f"\nβ = {Koef_Beta[N]}"
          "\n")
    D_Xr = Koef_Beta[N] * R

    print("-" * 40 +
          f"\n Случайная погрешность:"
          f"\n∆{letter} = {D_Xr} {izmer}"
          "\n")

    O_ = prib_pogr

    print("-" * 40 +
          f"\n Приборная погрешность:"
          f"\nθ({letter}) = {O_} {izmer}"
          "\n")
    # Полная погрешность

    D_X_ = (D_Xr**2 + O_**2)**0.5

    print("-" * 40 +
          f"\n Полная погрешность:"
          f"\n∆{letter}‾ = {D_X_} {izmer}"
          "\n")

    # Относительная погрешность
    # В душе не чаю как называется буква пусть будет биба (хотя это прописная дельта)

    biba = (D_X_ / X_) * 100
    print("-" * 40 +
          f"\n Относительная погрешность:"
          f"\nδ = {biba} {izmer}"
          "\n")


    print("-" * 40 + '\n'+ "-" * 40 +
        f"""
    Результат:
    {X} = {X_} ± {D_X_}
    δ = {biba}
    P = 95%
    N = {N}
    """)
    print("!" * 40)
    return (X_, D_X_)

if __name__ == '__main__':

    X = input('Введите букву величины, которую вы вычисляете:\n')

    izm = input('Введите физическое обозначение величины (с, Гц, 10**-30 Кл и т.д.)\n')

    all_vbka = input('Введите значения выборки через пробел (Очень желательно в СИ):\n').split()

    O_ = float(input('Введите приборную погрешность (простите, посчитайте ручками):\n'))

    all_vbka = [float(i) for i in all_vbka]

    pryam_pogr(all_vbka, O_, X, izm)

    input('Нажмите любую клавишу для выхода')




